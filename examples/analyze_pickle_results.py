#!/usr/bin/env python3
"""
Analyze Pickle Results with Pyfolio

This script demonstrates how to load backtest results from a pickle file
and create comprehensive Pyfolio analysis, exactly as you requested:

"Risk and performance metrics that are generated by the periodic, 
portfolio-level percentage returns of a strategy.
perf = pd.read_pickle("risk-parity.pickle")
returns, positions, transactions = pf.utils.extract_rets_pos_txn_from_zipline(perf)
pf.create_full_tear_sheet(returns, positions, transactions)

Risk and performance metrics that are generated by the individual trades within the strategy.
pf.create_round_trip_tear_sheet(returns, positions, transactions)"
"""

import os
import sys
import pandas as pd
import pyfolio as pf
import matplotlib.pyplot as plt
import warnings

# Add the parent directory to the path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Suppress warnings for cleaner output
warnings.filterwarnings('ignore')

def analyze_pickle_results(pickle_filepath, output_dir='pyfolio_results', live_start_date=None):
    """
    Analyze backtest results from a pickle file using Pyfolio.
    
    This function replicates exactly what you requested:
    1. Load results from pickle file
    2. Extract returns, positions, transactions
    3. Create full tear sheet (portfolio-level metrics)
    4. Create round trip tear sheet (individual trades metrics)
    
    Parameters:
    -----------
    pickle_filepath : str
        Path to the pickle file containing backtest results
    output_dir : str
        Directory to save analysis results
    live_start_date : str, optional
        Date when live trading started (for out-of-sample analysis)
    """
    
    print("üöÄ ANALYZING PICKLE RESULTS WITH PYFOLIO")
    print("=" * 50)
    print(f"üìÅ Pickle file: {pickle_filepath}")
    
    # Step 1: Load results from pickle (as you requested)
    print("\nüìÇ Loading results from pickle file...")
    try:
        perf = pd.read_pickle(pickle_filepath)
        print(f"‚úÖ Results loaded successfully")
        print(f"üìä Data shape: {perf.shape}")
        print(f"üìÖ Date range: {perf.index[0]} to {perf.index[-1]}")
        print(f"üí∞ Final portfolio value: ${perf['portfolio_value'].iloc[-1]:,.2f}")
    except Exception as e:
        print(f"‚ùå Failed to load pickle file: {str(e)}")
        return
    
    # Create output directory
    os.makedirs(output_dir, exist_ok=True)
    
    # Step 2: Extract returns, positions, transactions (as you requested)
    print("\nüîç Extracting returns, positions, and transactions from Zipline results...")
    try:
        returns, positions, transactions = pf.utils.extract_rets_pos_txn_from_zipline(perf)
        
        print(f"üìà Returns: {len(returns)} data points")
        print(f"üìä Positions: {len(positions) if positions is not None else 0} records")
        print(f"üí± Transactions: {len(transactions) if transactions is not None else 0} records")
        
    except Exception as e:
        print(f"‚ùå Failed to extract data: {str(e)}")
        return
    
    # Parse live start date if provided
    live_start_date_parsed = None
    if live_start_date:
        live_start_date_parsed = pd.Timestamp(live_start_date)
        print(f"üìÖ Live start date: {live_start_date_parsed}")
    
    # Step 3: Create full tear sheet (portfolio-level metrics as you requested)
    print("\nüìä Creating full tear sheet (portfolio-level performance metrics)...")
    try:
        plt.figure(figsize=(16, 12))
        
        # This is exactly what you requested:
        pf.create_full_tear_sheet(
            returns, 
            positions=positions, 
            transactions=transactions,
            live_start_date=live_start_date_parsed
        )
        
        # Save the plot
        full_tearsheet_path = os.path.join(output_dir, 'full_tear_sheet.png')
        plt.savefig(full_tearsheet_path, dpi=300, bbox_inches='tight')
        plt.close()
        
        print(f"‚úÖ Full tear sheet created and saved: {full_tearsheet_path}")
        
    except Exception as e:
        print(f"‚ö†Ô∏è  Full tear sheet creation failed: {str(e)}")
    
    # Step 4: Create round trip tear sheet (individual trades as you requested)
    print("\nüîÑ Creating round trip tear sheet (individual trades performance)...")
    try:
        if transactions is not None and len(transactions) > 0:
            plt.figure(figsize=(16, 12))
            
            # This is exactly what you requested:
            pf.create_round_trip_tear_sheet(
                returns, 
                positions=positions, 
                transactions=transactions
            )
            
            # Save the plot
            round_trip_path = os.path.join(output_dir, 'round_trip_tear_sheet.png')
            plt.savefig(round_trip_path, dpi=300, bbox_inches='tight')
            plt.close()
            
            print(f"‚úÖ Round trip tear sheet created and saved: {round_trip_path}")
            
        else:
            print("‚ö†Ô∏è  No transactions available for round trip analysis")
            
    except Exception as e:
        print(f"‚ö†Ô∏è  Round trip tear sheet creation failed: {str(e)}")
    
    # Step 5: Save data to CSV files for further analysis
    print("\nüíæ Saving extracted data to CSV files...")
    try:
        # Save returns
        returns_path = os.path.join(output_dir, 'returns.csv')
        returns.to_csv(returns_path)
        print(f"‚úÖ Returns saved: {returns_path}")
        
        # Save positions if available
        if positions is not None and len(positions) > 0:
            positions_path = os.path.join(output_dir, 'positions.csv')
            positions.to_csv(positions_path)
            print(f"‚úÖ Positions saved: {positions_path}")
        
        # Save transactions if available
        if transactions is not None and len(transactions) > 0:
            transactions_path = os.path.join(output_dir, 'transactions.csv')
            transactions.to_csv(transactions_path)
            print(f"‚úÖ Transactions saved: {transactions_path}")
            
    except Exception as e:
        print(f"‚ö†Ô∏è  CSV saving failed: {str(e)}")
    
    print(f"\n‚úÖ ANALYSIS COMPLETED!")
    print(f"üìÅ All results saved to: {os.path.abspath(output_dir)}")
    
    # Display summary statistics
    print(f"\nüìä SUMMARY STATISTICS:")
    print(f"   üí∞ Total Return: {(returns + 1).prod() - 1:.2%}")
    print(f"   üìà Annualized Return: {pf.timeseries.annual_return(returns):.2%}")
    print(f"   üìä Sharpe Ratio: {pf.timeseries.sharpe_ratio(returns):.2f}")
    print(f"   üìâ Max Drawdown: {pf.timeseries.max_drawdown(returns):.2%}")
    print(f"   üéØ Win Rate: {(returns > 0).mean():.1%}")

def main():
    """
    Main function - you can modify this to point to your pickle file
    """
    
    # Example usage - modify the pickle file path as needed
    pickle_file = "backtest_results.pickle"  # Change this to your pickle file
    
    if len(sys.argv) > 1:
        pickle_file = sys.argv[1]
    
    if not os.path.exists(pickle_file):
        print(f"‚ùå Pickle file not found: {pickle_file}")
        print("\nüí° Usage:")
        print(f"python {sys.argv[0]} <path_to_pickle_file>")
        print("\nOr modify the pickle_file variable in the script")
        return
    
    # Run the analysis
    analyze_pickle_results(
        pickle_filepath=pickle_file,
        output_dir='pyfolio_analysis',
        live_start_date=None  # Set this if you want out-of-sample analysis
    )

if __name__ == "__main__":
    main()
